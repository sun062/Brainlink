<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainwave Data Analyzer (뇌파 분석 대시보드)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- SheetJS CDN for spreadsheet parsing (CSV, XLSX) -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <!-- PapaParse CDN for structured CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <!-- Lucide Icons -->
    <script type="module" src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Noto+Sans+KR:wght@100..900&display=swap');
        body { font-family: 'Noto Sans KR', 'Inter', sans-serif; background-color: #f1f5f9; /* slate-100 equivalent */ }
        .card { background-color: white; border-radius: 1.0rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); transition: transform 0.2s; }
        .card:hover { transform: translateY(-2px); }
        .metric-value { font-size: 2.5rem; font-weight: 700; }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .spin { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Narrative Styles for enhanced readability */
        .narrative-section { margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #e2e8f0; /* slate-200 */ }
        .narrative-title { font-size: 1.25rem; font-weight: 700; color: #475569; /* slate-600 */ margin-bottom: 0.75rem; display: flex; align-items: center; }
        .ratio-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 1rem; margin-top: 1rem; }
        /* Mobile adjustment for ratio grid */
        @media (min-width: 768px) {
             .ratio-grid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        }
        .ratio-item { padding: 0.5rem 0.75rem; border-radius: 0.5rem; background-color: #f8fafc; /* slate-50 */ text-align: center; }
        .ratio-item strong { display: block; font-size: 1.1rem; color: #1e293b; /* slate-900 */ }
        .ratio-item span { font-size: 0.75rem; color: #64748b; /* slate-500 */ }
        /* Custom styles for the scrollable chart */
        .chart-legend-item.hidden-line span:last-child {
            text-decoration: line-through;
            opacity: 0.5;
        }
        .chart-legend-item { cursor: pointer; }

        /* Robot Arm CSS for Animation */
        #robot-scene #upper-arm-rect,
        #robot-scene #forearm-group,
        #robot-scene #jaw-left,
        #robot-scene #jaw-right {
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #robot-scene #apple {
            transition: transform 1.0s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s;
        }
        /* Sticky Navigation Bar Styling */
        .sticky-nav {
            top: 0;
            z-index: 100;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .analysis-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Updated styles for Session Info Horizontal Layout (FLEX container) */
        .session-info-grid {
            display: flex;
            flex-direction: row; /* Forces horizontal layout */
            overflow-x: auto; /* Allows horizontal scrolling on small screens */
            gap: 1rem;
            padding: 0.5rem 0;
            margin-top: 1rem;
        }
        .info-item {
            min-width: 180px; /* Ensure minimum size for readability */
            flex-shrink: 0; /* Important: prevents items from shrinking vertically */
            padding: 0.75rem;
            border-radius: 0.75rem;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            border-left: 3px solid #94a3b8; /* slate-400 for accent */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <svg class="spin h-10 w-10 text-slate-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span class="ml-3 text-lg text-gray-700">데이터를 분석 중입니다...</span>
    </div>

    <header class="mb-8 text-center">
        <h1 class="text-4xl font-extrabold text-slate-700">Brainwave Lite 데이터 분석기</h1>
        <p class="text-gray-600 mt-2">스프레드시트 파일 (.xlsx, .csv) 업로드를 통해 집중도, 피로도, 안정도를 분석합니다.</p>
    </header>
    
    <!-- Navigation Buttons -->
    <nav id="nav-buttons" class="hidden sticky sticky-nav py-3 mb-6 z-10 rounded-xl p-4 flex flex-wrap justify-center gap-3">
        <button onclick="scrollToSection('metrics-section')" class="nav-btn bg-slate-100 text-slate-700 hover:bg-slate-200 px-4 py-2 rounded-full font-semibold text-sm transition">
            1. 주요 지표
        </button>
        <button onclick="scrollToSection('narrative-section-anchor')" class="nav-btn bg-slate-100 text-slate-700 hover:bg-slate-200 px-4 py-2 rounded-full font-semibold text-sm transition">
            2. 상세 리포트
        </button>
        <button onclick="scrollToSection('charts-section')" class="nav-btn bg-slate-100 text-slate-700 hover:bg-slate-200 px-4 py-2 rounded-full font-semibold text-sm transition">
            3. 뇌파 추이 그래프
        </button>
        <button onclick="scrollToSection('robot-arm-section-anchor')" class="nav-btn bg-slate-100 text-slate-700 hover:bg-slate-200 px-4 py-2 rounded-full font-semibold text-sm transition">
            4. 로봇팔 시뮬레이션
        </button>
    </nav>

    <!-- File Upload Section (with Analysis Button) -->
    <div id="upload-section" class="card p-6 mb-8 border-2 border-dashed border-slate-300">
        <label for="csv-file" class="block text-xl font-semibold mb-3 text-gray-700">1. Brainwave 스프레드시트 파일 (.xlsx, .csv) 선택</label>
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 items-center">
            <!-- File Input -->
            <input type="file" id="csv-file" accept=".csv, .xlsx, .xls" class="flex-grow w-full md:w-auto text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 cursor-pointer">
            
            <!-- Analysis Button -->
            <button id="analyze-btn" class="analysis-btn bg-slate-600 hover:bg-slate-700 text-white font-semibold px-6 py-2 rounded-full transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-full md:w-auto" disabled>
                <i data-lucide="brain-circuit" class="w-5 h-5 mr-2 inline-block"></i>
                분석 시작
            </button>
        </div>
        <div id="format-message" class="mt-3 text-sm text-gray-500">
            파일을 업로드하면 형식을 자동 감지하여 분석합니다.
        </div>
    </div>

    <!-- Analysis Results Section -->
    <div id="results-section" class="hidden">

        <!-- Session Selection and Info (IMPROVED HORIZONTAL LAYOUT) -->
        <div class="card p-6 mb-8 bg-slate-50 border-l-4 border-slate-500">
            <!-- 1. Horizontal Title (가로로 작성 요청 반영) -->
            <h2 class="text-2xl font-bold text-slate-800 text-center mb-4">분석 세션 정보</h2>

            <!-- 2. Session Selector (가로 작성 아래 항목 선택 요청 반영) -->
            <div class="flex flex-col md:flex-row items-center justify-center mb-4">
                <label for="session-selector" class="text-sm font-medium text-slate-700 block mr-2">세션 선택:</label>
                <select id="session-selector" class="p-2 border border-slate-300 rounded-lg focus:ring-slate-500 focus:border-slate-500 w-full md:w-auto"></select>
            </div>
            
            <!-- Session Info Grid (Horizontal Flow) -->
            <div id="session-info-grid" class="session-info-grid">
                <!-- Data will be injected here by JS -->
            </div>
        </div>
        
        <!-- Anchor for Navigation -->
        <a id="metrics-section" class="anchor-point block relative -top-24"></a>
        
        <!-- Metric Cards -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4">2. 주요 분석 지표</h2>
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-6 mb-8">
            <!-- Attention Card -->
            <div class="card p-6 bg-blue-50 border-b-4 border-blue-500">
                <div class="flex items-center justify-between">
                    <span class="text-lg font-medium text-blue-800">집중도 (Attention Score)</span>
                    <i data-lucide="eye" class="w-6 h-6 text-blue-500"></i>
                </div>
                <p id="metric-attention" class="metric-value text-blue-700 mt-4">--</p>
                <p class="text-sm text-blue-600">Brainlink 원시 집중 점수 (0-100)</p>
            </div>

            <!-- Relaxation Card -->
            <div class="card p-6 bg-green-50 border-b-4 border-green-500">
                <div class="flex items-center justify-between">
                    <span class="text-lg font-medium text-green-800">안정도 (Relaxation Score)</span>
                    <i data-lucide="leaf" class="w-6 h-6 text-green-500"></i>
                </div>
                <p id="metric-relaxation" class="metric-value text-green-700 mt-4">--</p>
                <p class="text-sm text-green-600">Brainlink 원시 이완 점수 (0-100)</p>
            </div>

            <!-- Derived Concentration Index (CI) Card -->
            <div class="card p-6 bg-purple-50 border-b-4 border-purple-500">
                <div class="flex items-center justify-between">
                    <span class="text-lg font-medium text-purple-800">파생 집중 지수 (CI)</span>
                    <i data-lucide="zap" class="w-6 h-6 text-purple-500"></i>
                </div>
                <p id="metric-ci" class="metric-value text-purple-700 mt-4">--</p>
                <p class="text-sm text-purple-600">인지 활동 / 휴식 (높을수록 집중)</p>
            </div>

            <!-- Derived Fatigue Index (FI) Card -->
            <div class="card p-6 bg-red-50 border-b-4 border-red-500">
                <div class="flex items-center justify-between">
                    <span class="text-lg font-medium text-red-800">파생 피로 지수 (FI)</span>
                    <i data-lucide="clock" class="w-6 h-6 text-red-500"></i>
                </div>
                <p id="metric-fi" class="metric-value text-red-700 mt-4">--</p>
                <p class="text-sm text-red-600">졸음 / 활동 (높을수록 피로)</p>
            </div>

            <!-- NEW: Alpha/Theta Ratio Card -->
            <div class="card p-6 bg-yellow-50 border-b-4 border-yellow-500">
                <div class="flex items-center justify-between">
                    <span class="text-lg font-medium text-yellow-800">알파/세타 비율 (A/T Ratio)</span>
                    <i data-lucide="wind" class="w-6 h-6 text-yellow-500"></i>
                </div>
                <p id="metric-at-ratio" class="metric-value text-yellow-700 mt-4">--</p>
                <p class="text-sm text-yellow-600">이완된 집중/명상 상태 지표</p>
            </div>
        </div>
        
        <!-- Anchor for Navigation -->
        <a id="narrative-section-anchor" class="anchor-point block relative -top-24"></a>
        
        <!-- Narrative Analysis Section (NEW & IMPROVED) -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4">3. 상세 뇌파 해석 리포트</h2>
        <div id="narrative-analysis" class="card p-6 mb-8 bg-white border border-gray-200">
            <p id="narrative-placeholder" class="text-gray-600 italic">세션을 선택하면 여기에 상세 분석 리포트가 표시됩니다.</p>
        </div>

        <!-- Anchor for Navigation -->
        <a id="charts-section" class="anchor-point block relative -top-24"></a>
        
        <!-- Charts Section (Section 4 - Improved Layout) -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4">4. 뇌파 변화 추이</h2>
        <div class="grid grid-cols-1 gap-6 mb-8">
            <!-- Wave Power Chart (Time Series - Full Width & Scrollable) -->
            <div class="card p-6">
                <h3 class="text-xl font-semibold mb-3 text-gray-700">시간 경과에 따른 뇌파 파워 변화 (좌우 스크롤 가능)</h3>
                
                <!-- Custom Legend (4 items per row) -->
                <div id="wave-chart-legend" class="flex flex-wrap justify-center gap-x-6 gap-y-2 mb-4">
                    <!-- Legend items will be injected here -->
                </div>

                <!-- Scrolling Container -->
                <div id="wave-chart-scroll-container" class="overflow-x-auto border rounded-lg bg-gray-50 p-2" style="height: 450px;">
                    <!-- Inner container with minimum width for scrolling (1200px is a good default width) -->
                    <div id="wave-chart-inner-container" style="min-width: 1200px; height: 100%;">
                        <canvas id="wave-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Power Distribution Chart (Radar - Full Width adjusted) -->
            <div class="card p-6 flex flex-col justify-center items-center w-full">
                <h3 class="text-xl font-semibold mb-3 text-gray-700">
                    뇌파 주파수별 평균 분포 (로그 스케일 적용)
                    <span class="block text-sm font-normal text-gray-500 mt-1">
                        *점 색깔로 주파수 그룹(예: 알파파 그룹 - 녹색)을 시각적으로 구분합니다.
                    </span>
                </h3>
                <!-- max-w-none ensures it takes full available width, mx-auto centers it visually -->
                <div class="w-full h-[400px] max-w-none md:max-w-lg lg:max-w-xl"> 
                    <canvas id="distribution-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Anchor for Navigation -->
        <a id="robot-arm-section-anchor" class="anchor-point block relative -top-24"></a>
        
        <!-- Robot Arm Simulation Section (NEW) -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4">5. 집중력 기반 로봇팔 시뮬레이션</h2>
        <div class="card p-6 mb-8 bg-white border border-gray-200">
            <!-- Input and Button -->
            <div class="mb-6 flex space-x-3 items-end">
                <div class="flex-grow">
                    <label for="time-input" class="block text-sm font-medium text-gray-700 mb-1">분석할 시간 입력 (초):</label>
                    <input type="number" id="time-input" min="0" placeholder="0에서 세션 지속 시간 사이"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:ring-slate-500 focus:border-slate-500" disabled>
                </div>
                <button id="run-simulation-btn" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold px-4 py-2 rounded-lg transition duration-150 flex-shrink-0" disabled>
                    <i data-lucide="play" class="w-5 h-5 mr-1 inline-block"></i> 시뮬레이션 실행
                </button>
            </div>

            <!-- Simulation Output & Visual -->
            <div class="bg-gray-100 border p-4 rounded-lg relative overflow-hidden h-72 flex items-end justify-center">
                <div id="simulation-message" class="absolute top-4 left-1/2 transform -translate-x-1/2 text-lg font-semibold text-gray-600 p-2 bg-white rounded-lg shadow-md">세션을 선택하고 시간을 입력해주세요.</div>
                
                <svg id="robot-scene" viewBox="0 0 400 250" class="w-full h-full">
                    <!-- Ground/Base -->
                    <rect x="0" y="240" width="400" height="10" fill="#374151"/>
                    
                    <!-- Robot Arm Base -->
                    <rect x="50" y="210" width="40" height="30" fill="#6B7280"/>
                    
                    <!-- Apple (Target) - Initial position: translate(300, 210) -->
                    <g id="apple" transform="translate(300, 210)" style="opacity: 1;">
                        <circle cx="0" cy="0" r="10" fill="#ef4444" stroke="#b91c1c" stroke-width="1"/>
                        <rect x="-1" y="-18" width="2" height="8" fill="#10b981"/>
                        <path d="M-1 -10 C -5 -12, -5 -17, -1 -17" fill="none" stroke="#10b981" stroke-width="2"/>
                    </g>
                    
                    <!-- Robot Arm Structure -->
                    <g id="robot-arm" transform="translate(70, 210)">
                        <!-- Shoulder -->
                        <circle cx="0" cy="0" r="8" fill="#1F2937"/>
                        
                        <!-- Upper Arm -->
                        <!-- Initial state: rotate(0) for vertical arm -->
                        <rect x="-7" y="-80" width="14" height="80" fill="#9CA3AF" transform="rotate(0, 0, 0)" id="upper-arm-rect" style="transform-origin: 50% 100%;"/>
                        
                        <!-- Forearm & Gripper -->
                        <g id="forearm-group" transform="translate(0, -80)">
                            <!-- Elbow -->
                            <circle cx="0" cy="0" r="6" fill="#1F2937"/>
                            
                            <!-- Forearm -->
                            <!-- Initial state: rotate(0) for vertical forearm -->
                            <rect x="-5" y="-70" width="10" height="70" fill="#4B5563" transform="rotate(0, 0, 0)" id="forearm-rect" style="transform-origin: 50% 100%;"/>
                            
                            <!-- Gripper -->
                            <g id="gripper-group" transform="translate(0, -70)">
                                <!-- Wrist -->
                                <circle cx="0" cy="0" r="4" fill="#1F2937"/>
                                
                                <!-- Gripper Jaws (Open/Closed state handled by JS) -->
                                <!-- Jaw Left -->
                                <rect x="-10" y="-15" width="8" height="15" fill="#9CA3AF" transform="rotate(0, 0, 0)" id="jaw-left" style="transform-origin: 100% 100%;"/>
                                <!-- Jaw Right -->
                                <rect x="2" y="-15" width="8" height="15" fill="#9CA3AF" transform="rotate(0, 0, 0)" id="jaw-right" style="transform-origin: 0% 100%;"/>

                            </g>
                        </g>
                    </g>
                </svg>
            </div>
        </div>


    </div>

    <footer class="mt-12 text-center text-gray-500 text-sm">
        &copy; 2025 Brainwave Analyzer. Analysis based on standard EEG metrics.
    </footer>

    <!-- Firebase Setup (Mandatory in this environment) -->
    <script type="module">
        // Firebase setup is mandatory but not used for the core CSV analysis logic.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth;

        if (Object.keys(firebaseConfig).length > 0) {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('Debug');

                async function authenticate() {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                    }
                }
                authenticate();
            } catch(e) {
                 console.error("Firebase Initialization Failed:", e);
            }
        }
    </script>
    
    <script>
        let allSessions = {};
        let waveChart = null;
        let distributionChart = null;
        
        // --- CONSTANTS AND CONFIGURATION ---
        // Added 'groupColor' for visual differentiation on the radar chart
        const WAVE_COLORS = {
            Delta: { name: "델타 (깊은 수면)", color: 'rgb(239, 68, 68)', avgColor: '#EF4444', groupColor: 'rgb(239, 68, 68)' },
            Theta: { name: "세타 (졸음/이완)", color: 'rgb(59, 130, 246)', avgColor: '#3B82F6', groupColor: 'rgb(59, 130, 246)' },
            LowAlpha: { name: "저주파 알파 (휴식)", color: 'rgb(245, 158, 11)', avgColor: '#FBBF24', groupColor: 'rgb(16, 185, 129)' }, // Grouped as Alpha (Emerald)
            HighAlpha: { name: "고주파 알파 (평온)", color: 'rgb(16, 185, 129)', avgColor: '#10B981', groupColor: 'rgb(16, 185, 129)' }, // Grouped as Alpha (Emerald)
            LowBeta: { name: "저주파 베타 (집중/인지)", color: 'rgb(139, 92, 246)', avgColor: '#8B5CF6', groupColor: 'rgb(139, 92, 246)' }, // Grouped as Beta (Violet)
            HighBeta: { name: "고주파 베타 (스트레스)", color: 'rgb(249, 115, 22)', avgColor: '#F97316', groupColor: 'rgb(139, 92, 246)' }, // Grouped as Beta (Violet)
            LowGamma: { name: "저주파 감마 (고차인지)", color: 'rgb(107, 114, 128)', avgColor: '#6B7280', groupColor: 'rgb(31, 41, 55)' }, // Grouped as Gamma (Dark Gray)
            MidGamma: { name: "고주파 감마 (통합)", color: 'rgb(31, 41, 55)', avgColor: '#1F2937', groupColor: 'rgb(31, 41, 55)' }, // Grouped as Gamma (Dark Gray)
            Attention: { name: "집중도", color: 'rgb(22, 163, 74)', avgColor: '#16A34A' },
            Relaxation: { name: "안정도", color: 'rgb(147, 51, 234)', avgColor: '#9333EA' }
        };

        const CHART_ORDER = ['Delta', 'Theta', 'LowAlpha', 'HighAlpha', 'LowBeta', 'HighBeta', 'LowGamma', 'MidGamma'];

        // Keys MUST be lowercased and contain parts of the multilingual header for robust matching
        const COMPRESSED_COLUMN_MAP_KEYS = {
            'attention/注意力': 'Attention',
            'relaxation/放松度': 'Relaxation',
            'delta/δ波': 'Delta',
            'theta/θ波': 'Theta',
            'low-alpha/低α波': 'LowAlpha',
            'high-alpha/高α波': 'HighAlpha',
            'low-beta/低β波': 'LowBeta',
            'high-beta/高β波': 'HighBeta',
            'low-gamma/低γ波': 'LowGamma',
            'mid-gamma/高γ波': 'MidGamma',
            'date/日期': 'Date',
            'duration/时长/초': 'Duration',
            'tag/备注': 'Tag',
        };
        
        // Robust column mapping keys for the standard time-series format
        const STANDARD_COLUMN_MAP_KEYS = {
            'time/시간': 'Time',
            'timestamp/타임스탬프': 'Time',
            'attention/주의력': 'Attention',
            'relaxation/이완': 'Relaxation',
            'delta/델타': 'Delta',
            'theta/세타': 'Theta',
            'low-alpha/저주파알파': 'LowAlpha',
            'high-alpha/고주파알파': 'HighAlpha',
            'low-beta/저주파베타': 'LowBeta',
            'high-beta/고주파베타': 'HighBeta',
            'low-gamma/저주파감마': 'LowGamma',
            'mid-gamma/고주파감마': 'MidGamma',
        };

        // --- UTILITY FUNCTIONS ---

        /**
         * Custom alert box replacement for modal-like messages.
         */
        function alertBox(title, message, type = 'blue') {
            const resultSection = document.getElementById('results-section');
            const alertId = 'custom-alert-' + Date.now();
            const colorMap = {
                blue: { bg: 'bg-slate-100', text: 'text-slate-800', border: 'border-slate-500' },
                red: { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-500' },
                green: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-500' }
            };
            const colors = colorMap[type] || colorMap.blue;

            const alertHtml = `
                <div id="${alertId}" class="fixed inset-0 z-[2000] flex items-center justify-center p-4">
                    <div class="absolute inset-0 bg-gray-900 opacity-50"></div>
                    <div class="relative ${colors.bg} ${colors.text} border-l-4 ${colors.border} p-4 rounded-lg shadow-xl max-w-sm w-full">
                        <div class="font-bold text-lg mb-2">${title}</div>
                        <p class="text-sm">${message}</p>
                        <div class="mt-4 flex justify-end">
                            <button onclick="document.getElementById('${alertId}').remove();" class="px-3 py-1 text-sm font-medium rounded-md ${colors.text} bg-white hover:bg-gray-50 transition">
                                확인
                            </button>
                        </div>
                    </div>
                </div>
            `;
            // Append to body, or result section if available
            (resultSection || document.body).insertAdjacentHTML('beforeend', alertHtml);
        }
        window.alertBox = alertBox; // Expose globally

        /**
         * Smoothly scrolls to the target section.
         */
        function scrollToSection(id) {
            const element = document.getElementById(id);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth' });
            }
        }
        window.scrollToSection = scrollToSection; // Expose globally

        /**
         * Cleans header text for robust matching.
         */
        function cleanHeader(header) {
            if (!header) return '';
            // Convert to lowercase and remove non-alphanumeric/non-CJK characters (except for the core identifier parts)
            return String(header).toLowerCase().replace(/[\s\(\)/:\u4e00-\u9fa5\u3040-\u30ff\uac00-\ud7a3]/g, '').trim(); 
        }

        /**
         * Creates a column index map by matching raw headers to a predefined map (e.g., COMPRESSED or STANDARD).
         */
        function mapColumns(headerRow, mapKeys) {
            const colIndexMap = {};
            const cleanedMap = Object.keys(mapKeys).reduce((acc, key) => {
                acc[cleanHeader(key)] = mapKeys[key];
                return acc;
            }, {});

            for (let i = 0; i < headerRow.length; i++) {
                const headerText = String(headerRow[i]);
                const cleaned = cleanHeader(headerText);
                
                // Try to find a match where the cleaned header contains the cleaned map key, or vice-versa
                for (const key in cleanedMap) {
                    if (cleaned.includes(key) || key.includes(cleaned)) {
                        colIndexMap[cleanedMap[key]] = i;
                        break;
                    }
                }
            }
            return colIndexMap;
        }

        /**
         * Parses the compressed data format (session summary rows with comma-separated data).
         */
        function parseCompressedSessionData(rawRows) {
            const sessions = {};
            if (!rawRows || rawRows.length < 2) return sessions;

            const headerRow = rawRows[0];
            const dataRows = rawRows.slice(1).filter(row => row && row.length > 3 && row[0]);

            if (dataRows.length === 0) return sessions;

            const colIndexMap = mapColumns(headerRow, COMPRESSED_COLUMN_MAP_KEYS);
            const essentialCols = ['Attention', 'Relaxation', 'Delta'];
            if (!essentialCols.every(col => colIndexMap[col] !== undefined)) {
                 // Essential columns not found for compressed format
                return sessions;
            }

            // 2. Process Data Rows
            dataRows.forEach((row, index) => {
                const dateVal = row[colIndexMap.Date] || `N/A - Session ${index + 1}`;
                const sessionId = `${dateVal}_${index}`;
                
                const session = {
                    id: sessionId,
                    Date: dateVal,
                    Duration: parseInt(row[colIndexMap.Duration] || 0) || 0,
                    Tag: row[colIndexMap.Tag] || 'None',
                    RawData: {},
                    Format: 'Compressed'
                };

                let dataLength = 0;

                // Iterate over wave keys and parse the comma-separated string
                ['Attention', 'Relaxation', ...CHART_ORDER].forEach(propName => {
                    const colIndex = colIndexMap[propName];

                    if (colIndex !== undefined) {
                        let cellValue = row[colIndex] ? String(row[colIndex]).trim() : '';

                        // Remove surrounding quotes if present (e.g., "48,48,35,...")
                        if (cellValue.startsWith('"') && cellValue.endsWith('"')) {
                            cellValue = cellValue.slice(1, -1);
                        }

                        // Parse the compressed string into an array of numbers
                        const dataArray = cellValue
                            .split(',')
                            .map(s => {
                                const num = parseFloat(s.trim());
                                return isNaN(num) ? 0 : num;
                            })
                            .filter(n => typeof n === 'number');

                        session.RawData[propName] = dataArray;
                        
                        if (dataArray.length > 0) {
                            dataLength = Math.max(dataLength, dataArray.length);
                        }
                    }
                });
                
                session.SampleCount = dataLength;
                
                if (dataLength > 0 && session.RawData.Attention && session.RawData.Attention.length > 0) {
                    sessions[sessionId] = session;
                }
            });

            return sessions;
        }

        /**
         * Parses the standard time-series data format (each row is one time point).
         */
        function parseStandardTimeSeriesData(rawRows) {
            const sessions = {};
            if (!rawRows || rawRows.length < 2) return sessions;
            
            const headerRow = rawRows[0];
            const dataRows = rawRows.slice(1).filter(row => row && row.length > 1);

            if (dataRows.length === 0) return sessions;

            const colIndexMap = mapColumns(headerRow, STANDARD_COLUMN_MAP_KEYS);
            const essentialCols = ['Attention', 'Relaxation', 'Delta', 'Theta'];
            
            // Must have at least the core waves and metrics
            if (!essentialCols.every(col => colIndexMap[col] !== undefined)) {
                console.warn("Standard parsing failed: Essential columns not found.");
                return sessions;
            }

            // Create a single session for the continuous stream
            const sessionId = 'standard_stream_session';
            const session = {
                id: sessionId,
                Date: 'Continuous Stream',
                Duration: dataRows.length,
                Tag: 'Standard Time Series',
                RawData: {},
                SampleCount: dataRows.length,
                Format: 'Standard'
            };

            // Initialize RawData arrays
            const allProps = ['Attention', 'Relaxation', ...CHART_ORDER];
            allProps.forEach(prop => session.RawData[prop] = []);

            // Aggregate data row by row
            dataRows.forEach(row => {
                allProps.forEach(propName => {
                    const colIndex = colIndexMap[propName];
                    if (colIndex !== undefined) {
                        const value = parseFloat(row[colIndex]);
                        session.RawData[propName].push(isNaN(value) ? 0 : value);
                    } else {
                        // If a wave is missing in the file, push 0 to keep array lengths consistent
                        session.RawData[propName].push(0);
                    }
                });
            });
            
            // Final check
            if (session.RawData.Attention.length > 0) {
                 sessions[sessionId] = session;
            }
           
            return sessions;
        }

        // --- MAIN ANALYSIS AND DISPLAY LOGIC ---

        /**
         * Calculates key metrics for the session.
         */
        function calculateSessionMetrics(session) {
            const { RawData } = session;

            // 1. Calculate Averages for all waves
            const averages = {};
            CHART_ORDER.forEach(wave => {
                const sum = RawData[wave].reduce((a, b) => a + b, 0);
                averages[wave] = sum / (RawData[wave].length || 1);
            });

            // 2. Calculate Derived Indices
            
            // Concentration Index (CI) = (Beta + Gamma) / (Theta + Alpha) - Simplified for general use
            const CI_NUM = (averages.LowBeta || 0) + (averages.HighBeta || 0) + (averages.LowGamma || 0) + (averages.MidGamma || 0);
            const CI_DEN = (averages.Theta || 0) + (averages.LowAlpha || 0) + (averages.HighAlpha || 0);
            session.ConcentrationIndex = CI_DEN > 0 ? (CI_NUM / CI_DEN).toFixed(2) : CI_NUM.toFixed(2);
            
            // Fatigue Index (FI) = Theta / (Low Beta + High Beta) - Indicator of drowsiness
            const FI_NUM = averages.Theta || 0;
            const FI_DEN = (averages.LowBeta || 0) + (averages.HighBeta || 0);
            session.FatigueIndex = FI_DEN > 0 ? (FI_NUM / FI_DEN).toFixed(2) : FI_NUM.toFixed(2);

            // NEW: Alpha/Theta Ratio (A/T Ratio) = Alpha / Theta - For meditative/relaxed focus
            const AT_NUM = (averages.LowAlpha || 0) + (averages.HighAlpha || 0);
            const AT_DEN = averages.Theta || 0;
            session.AlphaThetaRatio = AT_DEN > 0 ? (AT_NUM / AT_DEN).toFixed(2) : AT_NUM.toFixed(2);
            
            // Overall Metrics
            session.AvgAttention = RawData.Attention.reduce((a, b) => a + b, 0) / (RawData.Attention.length || 1);
            session.AvgRelaxation = RawData.Relaxation.reduce((a, b) => a + b, 0) / (RawData.Relaxation.length || 1);
            session.WaveAverages = averages;

            return session;
        }

        /**
         * Generates a descriptive narrative report based on the calculated metrics.
         */
        function generateNarrativeAnalysis(session) {
            const { AvgAttention, AvgRelaxation, ConcentrationIndex, FatigueIndex, AlphaThetaRatio, WaveAverages } = session;
            
            // Determine primary states
            const CI_Num = parseFloat(ConcentrationIndex);
            const FI_Num = parseFloat(FatigueIndex);
            const AT_Num = parseFloat(AlphaThetaRatio);

            let overallState = '';
            if (AvgAttention >= 60 && CI_Num >= 1.2 && FI_Num < 0.8) {
                overallState = '매우 높음: 이 세션은 **최적의 집중 상태**와 안정적인 인지 활동을 보여줍니다. 학습 또는 문제 해결에 이상적인 상태였습니다.';
            } else if (AvgAttention >= 40 && CI_Num >= 1.0) {
                overallState = '높음: **양호한 집중력과 적절한 활동 수준**을 유지했습니다. 작업 효율성이 높았을 것으로 보입니다.';
            } else if (AvgAttention < 40 && FI_Num >= 1.0) {
                overallState = '경고: **집중력이 낮고 피로도가 높게** 나타났습니다. 휴식이 필요하거나 주의력 결핍이 발생했을 수 있습니다.';
            } else if (AvgRelaxation >= 60) {
                overallState = '이완/휴식: **매우 안정되고 이완된 상태**가 지배적이었습니다. 명상, 휴식, 또는 수면 준비에 적합한 상태입니다.';
            } else {
                overallState = '보통: 집중과 이완이 균형을 이루거나, 특정 경향이 두드러지지 않은 평이한 상태입니다.';
            }

            // Wave power analysis
            const availableWaves = CHART_ORDER.filter(wave => WaveAverages[wave] > 0);
            const dominantWave = availableWaves.length > 0 ? availableWaves.reduce((a, b) => (WaveAverages[a] > WaveAverages[b] ? a : b)) : null;
            
            let waveSummary = '뇌파 파워 데이터가 존재하지 않아 상세 주파수 분석이 제한됩니다.';
            if (dominantWave) {
                 if (dominantWave === 'LowBeta' || dominantWave === 'HighBeta') {
                    waveSummary = `주요 주파수는 **${WAVE_COLORS[dominantWave].name}**로, 이는 활발한 사고, 집중력, 또는 스트레스 수준의 증가를 시사합니다.`;
                } else if (dominantWave === 'Theta' || dominantWave === 'Delta') {
                    waveSummary = `주요 주파수는 **${WAVE_COLORS[dominantWave].name}**로, 이는 깊은 이완, 졸음, 또는 인지 부하 상태를 나타냅니다.`;
                } else if (dominantWave === 'HighAlpha' || dominantWave === 'LowAlpha') {
                    waveSummary = `주요 주파수는 **${WAVE_COLORS[dominantWave].name}**로, 이는 고요하고 명상적인 휴식 상태가 잘 유지되었음을 보여줍니다.`;
                }
            }


            // Ratio Interpretation
            let ratioComment = '핵심 지수 분석을 위한 충분한 뇌파 데이터가 존재하지 않습니다.';
            if (CI_Num > 0.01) { // Check if index calculation was meaningful
                let ciComment = `집중 지수(CI) ${CI_Num}: `;
                if (CI_Num > 1.2) {
                    ciComment += '높음 (뇌가 효율적으로 작동)';
                } else if (CI_Num > 0.8) {
                    ciComment += '보통 (균형 잡힌 인지 활동)';
                } else {
                    ciComment += '낮음 (활동력 저하)';
                }

                let fiComment = `피로 지수(FI) ${FI_Num}: `;
                if (FI_Num > 1.0) {
                    fiComment += '높음 (피로하거나 주의 산만)';
                } else if (FI_Num < 0.8) {
                    fiComment += '낮음 (경계 상태 유지)';
                } else {
                    fiComment += '보통 (적절한 수준)';
                }

                let atComment = `알파/세타 비율(A/T Ratio) ${AT_Num}: `;
                if (AT_Num > 2.0) {
                    atComment += '높음 (이완된 집중, 명상 상태에 유리)';
                } else if (AT_Num < 1.0) {
                    atComment += '낮음 (과도한 각성 또는 산만)';
                } else {
                    atComment += '보통 (안정적인 이완 상태)';
                }

                ratioComment = `${ciComment}. ${fiComment}. ${atComment}.`;
            }

            // Updated color for narrative title
            const html = `
                <div class="narrative-section">
                    <div class="narrative-title text-slate-700">
                         <i data-lucide="bar-chart-3" class="w-5 h-5 mr-2"></i> 세션 개요
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        이 세션은 태그 **'${session.Tag}'**(총 ${session.SampleCount}초/샘플)로 기록되었습니다.
                        평균 집중도는 **${AvgAttention.toFixed(1)}**점, 평균 안정도는 **${AvgRelaxation.toFixed(1)}**점을 기록했습니다.
                        전반적인 뇌 상태는 <span class="font-semibold text-slate-600">${overallState}</span>
                    </p>
                </div>

                <div class="narrative-section">
                    <div class="narrative-title text-slate-700">
                        <i data-lucide="ratio" class="w-5 h-5 mr-2"></i> 핵심 지수 분석
                    </div>
                    
                    <div class="ratio-grid">
                        <div class="ratio-item border-l-4 border-purple-500">
                            <strong>${ConcentrationIndex}</strong>
                            <span>집중 지수 (CI)</span>
                        </div>
                        <div class="ratio-item border-l-4 border-red-500">
                            <strong>${FatigueIndex}</strong>
                            <span>피로 지수 (FI)</span>
                        </div>
                        <div class="ratio-item border-l-4 border-yellow-500">
                            <strong>${AlphaThetaRatio}</strong>
                            <span>알파/세타 비율 (A/T)</span>
                        </div>
                    </div>
                    
                    <p class="text-gray-700 mt-3 leading-relaxed">
                        ${ratioComment}
                    </p>
                </div>

                <div class="narrative-section">
                    <div class="narrative-title text-slate-700">
                        <i data-lucide="activity" class="w-5 h-5 mr-2"></i> 주파수 분포 해석
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        ${waveSummary} **(레이더 차트에 로그 스케일이 적용되어 상대적 변화를 더 잘 보여줍니다. 각 주파수 대역별로 점 색상이 그룹화되어 있습니다.)**
                    </p>
                </div>
            `;
            
            const narrativeElement = document.getElementById('narrative-analysis');
            narrativeElement.innerHTML = html;
            // Re-render lucide icons
            lucide.createIcons(); 
        }

        /**
         * Updates the time-series line chart (Wave Chart).
         */
        function updateWaveChart(session) {
            const canvasId = 'wave-chart';
            const { RawData, SampleCount } = session;

            if (waveChart) {
                waveChart.destroy();
            }

            const timeLabels = Array.from({ length: SampleCount }, (_, i) => i + 1);

            const allProps = ['Attention', 'Relaxation', ...CHART_ORDER];
            
            const datasets = allProps
                .filter(prop => RawData[prop] && RawData[prop].length === SampleCount) // Only include datasets with matching length
                .map(prop => ({
                    label: WAVE_COLORS[prop].name,
                    data: RawData[prop],
                    borderColor: WAVE_COLORS[prop].color,
                    backgroundColor: WAVE_COLORS[prop].color + '40', // Semi-transparent
                    borderWidth: prop === 'Attention' || prop === 'Relaxation' ? 2 : 1.5,
                    pointRadius: 0,
                    tension: 0.1,
                    hidden: prop === 'Attention' || prop === 'Relaxation', // Hide metrics by default
                    fill: false,
                    yAxisID: prop === 'Attention' || prop === 'Relaxation' ? 'y1' : 'y' // Use secondary Y-axis for scores
            }));

            const config = {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: { display: false }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: '시간 (초 또는 샘플)' }
                        },
                        y: {
                            title: { display: true, text: '뇌파 파워 (μV²)', color: 'rgb(0, 0, 0)' },
                            position: 'left',
                            beginAtZero: true
                        },
                        y1: {
                            title: { display: true, text: '집중/안정도 (0-100)', color: WAVE_COLORS.Attention.color },
                            position: 'right',
                            min: 0,
                            max: 100,
                            grid: { drawOnChartArea: false }, // Only draw grid lines for the main Y-axis
                        }
                    },
                    animation: false
                }
            };

            const ctx = document.getElementById(canvasId).getContext('2d');
            waveChart = new Chart(ctx, config);

            // Create custom legend dynamically
            const legendContainer = document.getElementById(canvasId + '-legend');
            legendContainer.innerHTML = '';
            
            waveChart.data.datasets.forEach((dataset, index) => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('chart-legend-item', 'flex', 'items-center', 'space-x-1', 'text-sm', 'p-1', 'rounded-md', 'hover:bg-gray-100', 'transition');
                if (dataset.hidden) {
                    legendItem.classList.add('hidden-line');
                }
                legendItem.innerHTML = `
                    <span style="background-color:${dataset.borderColor};" class="w-3 h-3 rounded-full"></span>
                    <span class="text-gray-700">${dataset.label}</span>
                `;
                legendItem.onclick = () => toggleDatasetVisibility(canvasId, index);
                legendContainer.appendChild(legendItem);
            });
        }

        /**
         * Updates the radar chart showing average power distribution.
         */
        function updateDistributionChart(session) {
            const canvasId = 'distribution-chart';
            const { WaveAverages } = session;

            if (distributionChart) {
                distributionChart.destroy();
            }

            const relevantWaves = CHART_ORDER.filter(wave => WaveAverages[wave] > 0);

            if (relevantWaves.length === 0) {
                 // Hide chart or show placeholder if no wave data
                 document.getElementById(canvasId).style.display = 'none';
                 return;
            }
            document.getElementById(canvasId).style.display = 'block';

            // Data Transformation for better visualization (Log Scale)
            const logData = relevantWaves.map(wave => Math.log10(WaveAverages[wave] + 1)); // Log10(x+1)

            // Get point colors based on the new 'groupColor' for visual grouping
            const pointBackgroundColors = relevantWaves.map(wave => WAVE_COLORS[wave].groupColor);
            
            // Normalize log data to a 0-100 scale for radar visibility
            const maxValue = Math.max(...logData, 1);
            const normalizedData = logData.map(val => (val / maxValue) * 100);
            
            const labels = relevantWaves.map(wave => WAVE_COLORS[wave].name.split(' ')[0]); // e.g., "델타"

            const config = {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '평균 뇌파 파워 (로그 스케일)',
                        data: normalizedData,
                        backgroundColor: 'rgba(71, 85, 105, 0.4)', // Slate-600 with transparency for fill
                        borderColor: 'rgb(71, 85, 105)', // Slate-600 for line
                        pointBackgroundColor: pointBackgroundColors, // **Differentiated point colors**
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgb(71, 85, 105)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        r: {
                            angleLines: { color: '#e5e7eb' },
                            grid: { color: '#e5e7eb' },
                            pointLabels: {
                                font: { size: 12, family: 'Noto Sans KR, Inter, sans-serif' },
                                color: (context) => pointBackgroundColors[context.index] // Use group color for labels too
                            },
                            suggestedMin: 0,
                            suggestedMax: 100,
                            ticks: {
                                display: false // Hide numerical scale on radar chart
                            }
                        }
                    }
                }
            };
            
            const ctx = document.getElementById(canvasId).getContext('2d');
            distributionChart = new Chart(ctx, config);
        }

        /**
         * Toggles the visibility of a dataset in the time-series chart.
         */
        function toggleDatasetVisibility(chartId, datasetIndex) {
            const chart = Chart.getChart(chartId);
            if (!chart) return;

            const meta = chart.getDatasetMeta(datasetIndex);
            // Toggle visibility
            meta.hidden = !meta.hidden;

            // Update legend appearance
            const legendContainer = document.getElementById(chartId + '-legend');
            const legendItem = legendContainer.children[datasetIndex];
            if (legendItem) {
                legendItem.classList.toggle('hidden-line', meta.hidden);
            }

            // Update the chart to reflect changes
            chart.update();
        }
        window.toggleDatasetVisibility = toggleDatasetVisibility; // Expose globally

        /**
         * Updates the UI with metrics and triggers chart updates for the selected session.
         */
        function displaySessionAnalysis(session) {
            if (!session) return;
            
            // 1. Calculate Metrics
            const calculatedSession = calculateSessionMetrics(session);
            
            // 2. Update Metric Cards 
            document.getElementById('metric-attention').textContent = calculatedSession.AvgAttention.toFixed(1);
            document.getElementById('metric-relaxation').textContent = calculatedSession.AvgRelaxation.toFixed(1);
            document.getElementById('metric-ci').textContent = calculatedSession.ConcentrationIndex;
            document.getElementById('metric-fi').textContent = calculatedSession.FatigueIndex;
            document.getElementById('metric-at-ratio').textContent = calculatedSession.AlphaThetaRatio; // NEW METRIC

            // 3. Update Session Info (Horizontal Layout)
            const typeLabel = calculatedSession.Format === 'Standard' ? '표준 시계열 (스트림)' : '압축 세션 (요약)';
            
            const infoItems = [
                { icon: 'info', title: '데이터 형식', value: typeLabel, color: 'text-slate-600', border: 'border-slate-400' },
                { icon: 'calendar', title: '측정 날짜/시간', value: calculatedSession.Date, color: 'text-gray-600', border: 'border-gray-400' },
                { icon: 'tag', title: '세션 태그', value: calculatedSession.Tag, color: 'text-slate-600', border: 'border-slate-400' },
                { icon: 'clock', title: `데이터 포인트 (${calculatedSession.Format === 'Standard' ? '샘플' : '초'})`, value: `${calculatedSession.SampleCount}개`, color: 'text-gray-600', border: 'border-gray-400' }
            ];

            const infoGrid = document.getElementById('session-info-grid');
            // This map function generates the four info items in a row due to the .session-info-grid CSS
            infoGrid.innerHTML = infoItems.map(item => `
                <div class="info-item ${item.border}">
                    <div class="flex items-center space-x-2 mb-1">
                        <i data-lucide="${item.icon}" class="w-5 h-5 ${item.color}"></i>
                        <span class="text-sm font-semibold text-gray-600">${item.title}</span>
                    </div>
                    <p class="text-lg font-bold text-gray-800 truncate">${item.value}</p>
                </div>
            `).join('');
            
            // Re-render lucide icons in the new grid
            lucide.createIcons();

            // 4. Generate Narrative Report
            generateNarrativeAnalysis(calculatedSession);

            // 5. Update Charts
            updateWaveChart(calculatedSession);
            updateDistributionChart(calculatedSession);

            // 6. Initialize Robot Arm Simulation Controls
            const timeInput = document.getElementById('time-input');
            const runBtn = document.getElementById('run-simulation-btn');
            const maxDuration = calculatedSession.SampleCount;

            timeInput.max = maxDuration;
            timeInput.value = Math.min(60, maxDuration); // Default to 60s or max duration
            timeInput.disabled = false;
            runBtn.disabled = false;
            
            document.getElementById('simulation-message').textContent = `시뮬레이션 준비 완료: 최대 ${maxDuration}초/샘플까지 분석 가능`;
            document.getElementById('apple').style.opacity = '1'; // Reset apple visibility
            
            // Reset arm position
            document.getElementById('upper-arm-rect').style.transform = `rotate(0deg)`;
            document.getElementById('forearm-group').style.transform = `translate(0, -80px) rotate(0deg)`;
            document.getElementById('jaw-left').style.transform = `rotate(0deg)`;
            document.getElementById('jaw-right').style.transform = `rotate(0deg)`;
            
            // Ensure results section is visible and nav buttons are shown
            document.getElementById('results-section').classList.remove('hidden');
            document.getElementById('nav-buttons').classList.remove('hidden');
        }


        /**
         * Runs the robot arm simulation based on the Concentration Index at the given time.
         */
        function runRobotArmSimulation() {
            const timeInput = document.getElementById('time-input');
            const runBtn = document.getElementById('run-simulation-btn');
            const session = allSessions[document.getElementById('session-selector').value];
            
            if (!session || runBtn.disabled) return;

            const timeIndex = parseInt(timeInput.value) - 1; // 1-based to 0-based
            const maxDuration = session.SampleCount;

            if (timeIndex < 0 || timeIndex >= maxDuration) {
                alertBox('경고', `유효한 시간(1에서 ${maxDuration} 사이)을 입력해주세요.`, 'red');
                return;
            }

            // Get Attention score at the target time index
            const attentionScore = session.RawData.Attention[timeIndex] || 0;

            // 1. Determine action and speed based on Attention Score
            let statusMessage = '';
            let upperAngle = 0; 
            let forearmAngle = 0; 
            let isGripping = false;

            if (attentionScore >= 60) {
                statusMessage = `집중도 ${attentionScore.toFixed(0)}: 로봇팔이 사물을 **빠르게 정확하게** 집습니다. (최적의 상태)`;
                upperAngle = 55; 
                forearmAngle = 0; 
                isGripping = true;
            } else if (attentionScore >= 40) {
                statusMessage = `집중도 ${attentionScore.toFixed(0)}: 로봇팔이 사물을 **적절한 속도로** 집습니다. (양호한 상태)`;
                upperAngle = 45; 
                forearmAngle = 20; 
                isGripping = true;
            } else {
                statusMessage = `집중도 ${attentionScore.toFixed(0)}: **집중력 저하로 사물을 집는 데 실패**했습니다. (주의 필요)`;
                upperAngle = 20; 
                forearmAngle = 0;
                isGripping = false;
            }

            // 2. Animate the Arm
            const upperArm = document.getElementById('upper-arm-rect');
            const forearmGroup = document.getElementById('forearm-group');
            const jawLeft = document.getElementById('jaw-left');
            const jawRight = document.getElementById('jaw-right');
            const apple = document.getElementById('apple');
            const simulationMessage = document.getElementById('simulation-message');

            simulationMessage.textContent = '로봇팔 작동 중...';

            // Arm movement animation
            upperArm.style.transform = `rotate(${upperAngle}deg)`;
            forearmGroup.style.transform = `translate(0, -80px) rotate(${forearmAngle}deg)`;

            // Gripper animation (delay slightly after arm moves)
            setTimeout(() => {
                if (isGripping) {
                    jawLeft.style.transform = `rotate(15deg)`;
                    jawRight.style.transform = `rotate(-15deg)`;
                    
                    apple.style.opacity = '0';
                    apple.style.transform = `translate(300, 210) scale(0)`;
                    
                    setTimeout(() => {
                        simulationMessage.textContent = statusMessage;
                        
                         setTimeout(() => {
                            // Reset arm to vertical after a delay
                            upperArm.style.transform = `rotate(0deg)`;
                            forearmGroup.style.transform = `translate(0, -80px) rotate(0deg)`;
                            jawLeft.style.transform = `rotate(0deg)`;
                            jawRight.style.transform = `rotate(0deg)`;
                         }, 2000);

                    }, 800);

                } else {
                    jawLeft.style.transform = `rotate(0deg)`;
                    jawRight.style.transform = `rotate(0deg)`;

                    setTimeout(() => {
                        simulationMessage.textContent = statusMessage;
                        apple.style.opacity = '1';
                        apple.style.transform = `translate(300, 210) scale(1)`;
                        
                         setTimeout(() => {
                            upperArm.style.transform = `rotate(0deg)`;
                            forearmGroup.style.transform = `translate(0, -80px) rotate(0deg)`;
                         }, 2000);
                         
                    }, 800);
                }
            }, 800); 
        }
        window.runRobotArmSimulation = runRobotArmSimulation; 

        /**
         * Main click handler for the analysis button.
         */
        function handleAnalysisClick() {
            const fileInput = document.getElementById('csv-file');
            const files = fileInput.files;

            if (files.length === 0) {
                alertBox('경고', '먼저 파일을 선택해주세요.', 'blue');
                return;
            }

            const file = files[0];
            const reader = new FileReader();
            const loadingOverlay = document.getElementById('loading-overlay');
            const formatMessage = document.getElementById('format-message');
            loadingOverlay.style.display = 'flex';
            formatMessage.textContent = '데이터를 읽어들이는 중...';

            const isXlsx = file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls');

            reader.onload = function(e) {
                let data = e.target.result;

                if (isXlsx) {
                    try {
                        const workbook = XLSX.read(data, { type: 'binary' });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        data = XLSX.utils.sheet_to_csv(worksheet);
                    } catch (error) {
                         loadingOverlay.style.display = 'none';
                         alertBox('오류', 'XLSX 파일을 처리하는 중 오류가 발생했습니다. 파일이 손상되지 않았는지 확인해주세요.', 'red');
                         return;
                    }
                }

                // Use PapaParse to parse the data
                Papa.parse(data, {
                    header: false,
                    skipEmptyLines: true,
                    complete: (results) => {
                        try {
                            const rawRows = results.data;
                            allSessions = {};
                            formatMessage.textContent = '데이터 형식 감지 및 분석 시도 중...';

                            // 1. Attempt Compressed Format Parsing (Session Summaries)
                            const compressedSessions = parseCompressedSessionData(rawRows);

                            if (Object.keys(compressedSessions).length > 0) {
                                allSessions = compressedSessions;
                                formatMessage.textContent = `성공: 압축된 세션 요약 형식 (${Object.keys(allSessions).length}개 세션)으로 분석되었습니다.`;
                            } else {
                                // 2. Attempt Standard Format Parsing (Time Series)
                                const standardSessions = parseStandardTimeSeriesData(rawRows);
                                if (Object.keys(standardSessions).length > 0) {
                                    allSessions = standardSessions;
                                    formatMessage.textContent = '성공: 표준 시계열 형식 (단일 연속 스트림)으로 분석되었습니다.';
                                } else {
                                    alertBox('오류', '업로드된 파일에서 뇌파 데이터를 찾을 수 없거나 파일 형식이 지원되지 않습니다.', 'red');
                                    loadingOverlay.style.display = 'none';
                                    return;
                                }
                            }
                            
                            // Analysis Successful
                            const sessionIds = Object.keys(allSessions);
                            populateSessionSelector(sessionIds);
                            displaySessionAnalysis(allSessions[sessionIds[0]]);


                        } catch (error) {
                            alertBox('치명적 오류', '데이터 처리 중 예상치 못한 오류가 발생했습니다. 콘솔을 확인해주세요.', 'red');
                            console.error("Analysis Processing Error:", error);
                        } finally {
                            loadingOverlay.style.display = 'none';
                        }
                    },
                    error: (error) => {
                        loadingOverlay.style.display = 'none';
                        alertBox('파싱 오류', '파일을 읽는 데 실패했습니다. 파일이 유효한 CSV 또는 XLSX 형식인지 확인해주세요.', 'red');
                        console.error("PapaParse Error:", error);
                    }
                });
            };

            reader.onerror = function() {
                loadingOverlay.style.display = 'none';
                alertBox('파일 읽기 오류', '파일을 읽을 수 없습니다.', 'red');
            };

            // Start reading the file
            if (isXlsx) {
                reader.readAsBinaryString(file);
            } else {
                reader.readAsText(file);
            }
        }

        /**
         * Populates the session selector dropdown.
         */
        function populateSessionSelector(sessionIds) {
            const selector = document.getElementById('session-selector');
            selector.innerHTML = ''; 
            sessionIds.forEach(id => {
                const session = allSessions[id];
                const typeLabel = session.Format === 'Standard' ? '[스트림]' : `[${session.Tag}]`;
                const option = document.createElement('option');
                option.value = id;
                option.textContent = `${typeLabel} ${session.Date} (${session.SampleCount} ${session.Format === 'Standard' ? '샘플' : '초'})`;
                selector.appendChild(option);
            });
            selector.onchange = (e) => {
                displaySessionAnalysis(allSessions[e.target.value]);
            };
        }


        // --- INITIALIZATION ---
        window.onload = function() {
            lucide.createIcons(); 

            const analyzeBtn = document.getElementById('analyze-btn');
            const fileInput = document.getElementById('csv-file');
            const runSimBtn = document.getElementById('run-simulation-btn');
            const infoGrid = document.getElementById('session-info-grid');

            // 1. Enable/Disable Analyze Button on File Change
            fileInput.addEventListener('change', () => {
                analyzeBtn.disabled = fileInput.files.length === 0;
            });

            // 2. Set Main Analysis Listener
            analyzeBtn.addEventListener('click', handleAnalysisClick);
            
            // 3. Set Simulation Listener
            runSimBtn.addEventListener('click', runRobotArmSimulation);
            
            // 4. Initial message (Placeholder in new grid format)
            infoGrid.innerHTML = `
                <div class="info-item border-l-4 border-slate-300 col-span-full text-center text-gray-500 italic flex items-center justify-center p-4">
                    <i data-lucide="upload-cloud" class="w-5 h-5 inline-block mr-2"></i> 파일을 업로드하여 분석을 시작하세요.
                </div>
            `;
            lucide.createIcons(); // Re-render icon
        };
    </script>
</body>
</html>
